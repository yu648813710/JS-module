#### JS-module

##### 模块化开发的目的：

前端代码量日益臃肿，如果采用之前的简单规范进行开发，会导致前端项目无法代码混乱，变量名冲突等，所以就产生了模块化开发的概念，一个模块对应它相应的功能。

##### 模块：

JS没有类似于JAVA里包的概念，就是把逻辑相关的代码放进一个包中，是独立的不会与外部的命名冲突，但是JS没有这样的功能。ES6之后有了类的概念就有了

##### 模块化的发展：

- 函数分装：

    函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里写几个相关函数 就是最开始的模块化了 。
    
    `缺点：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。`

- 对象

    为了解决上面问题 ，对象的写法应运而生，可以把所有的模块成员封装在一个对象中，比如对象 myModule.fn1 ，引入相应的文件就可以这样去写。

    `优点：避免了全局变量的污染，只要保证对象模块名的唯一性就行。`
    `缺点：继承了对象的特性，外部可以直接修改方法，不太安全，比如 直接 myModule.fn1 =1；这时对象就变为1了。`

- 立即执行函数

    - `立即执行函数的解释 ：`

        利用运算符和（）直接执行函数如下图：

        从图中可以看出，除了使用()运算符之外，！，+，-，=等运算符都能起到立即执行的作用。这些运算符的作用就是将匿名函数或函数声明转换为函数表达式，不单单是匿名的可以执行 ，声明的函数表达式也可以立即执行。

        `优点：`

        立即执行函数直接匿名化了一个新的函数作用域，相当于创建了一个【私有】的命名空间，不会污染全局变量，可以利用传参传入对象，安全性也极高。JQ就是这种方式封装的代码

    `立即执行函数的写法是现在模块化的基础，目前JS模块化规范主要有两个 一个是commonjs和AMD以及CMD`

##### script标签：

`最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口`

- 缺点：
    - 全局作用域下容易造成变量冲突
    - 文件只能按照 < script > 的书写顺序进行加载
    - 在大型项目中各种资源难以管理

##### commonjs规范：

`CommonJS是服务器端模块的规范，由Node推广使用。由于服务端编程的复杂性，如果没有模块很难与操作系统及其他应用程序互动。使用方法如下。`


- 规范： 

    - 一个文件一个模块，每个模块是单独的作用域，无法被其他模块读取，除非定义为global全局对象
    - 输出模块的方法是module.exports对象
    - 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象

- 缺点：
    - 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的，服务器可以用的原因是磁盘加载，所以等待时长很短
    - 不能非阻塞的并行加载多个模块


##### AMD规范：

`推广requireJS中出来的规范，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。`

- 解决问题：

    - 多个js文件可能有依赖关系，被依赖的文件需要早期加载到浏览器
    - JS加载时页面会停止渲染，所以加载文件越多，页面响应时间越长。

- 优点：

    - 适合在浏览器环境中异步加载模块 
    - 可以并行加载多个模块 

- 缺点：

    - 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅 
    - 不符合通用的模块化思维方式，是一种妥协的实现 

##### CMD规范：

`CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，在 CMD 规范中，一个模块就是一个文件，AMD是依赖关系前置,在定义模块的时候就要声明其依赖的模块; CMD是按需加载依赖就近,只有在用到某个模块的时候再去require`

- 优点：
    - 依赖就近，延迟执行 
    - 可以很容易在 Node.js 中运行 
- 缺点：
    - 依赖 SPM 打包，模块的加载逻辑偏重 
    - API文档不齐全，学习成本高

#### `决定使用的模块规范AMD`
